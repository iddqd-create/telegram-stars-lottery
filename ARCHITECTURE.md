# Архитектура приложения Telegram Stars Lottery

Этот документ описывает техническую архитектуру приложения, взаимодействие компонентов и ключевые решения, принятые при разработке.

## Общая архитектура

Приложение построено по классической клиент-серверной архитектуре с использованием Telegram в качестве платформы:

```
┌─────────────────┐
│  Telegram User  │
└────────┬────────┘
         │
         │ (1) Opens Mini App
         ▼
┌─────────────────────────┐
│   Frontend (GitHub)     │
│   - HTML/CSS/JS         │
│   - Telegram WebApp API │
└────────┬────────────────┘
         │
         │ (2) API Requests (HTTPS)
         ▼
┌─────────────────────────┐
│   Backend (Render)      │
│   - Flask API           │
│   - SQLite Database     │
│   - Lottery Engine      │
└────────┬────────────────┘
         │
         │ (3) Bot API Calls
         ▼
┌─────────────────────────┐
│   Telegram Bot API      │
│   - Webhooks            │
│   - Payments (Stars)    │
│   - Notifications       │
└─────────────────────────┘
```

## Компоненты системы

### 1. Frontend (Telegram Mini App)

**Технологии:** HTML5, CSS3, Vanilla JavaScript, Telegram WebApp SDK

**Основные файлы:**
- `index.html` — структура приложения, все экраны
- `styles.css` — стили, анимации, адаптивный дизайн
- `app.js` — логика приложения, взаимодействие с API

**Экраны:**
1. **Loading Screen** — загрузка приложения, инициализация
2. **Menu Screen** — выбор ставки, статистика пользователя
3. **Waiting Room** — ожидание заполнения комнаты, real-time обновления
4. **Drawing Screen** — анимация розыгрыша
5. **Winner Screen** — объявление победителя, результаты

**Ключевые функции:**
- Валидация `initData` от Telegram для безопасной аутентификации
- Real-time обновления через Server-Sent Events (SSE)
- Открытие инвойсов через `Telegram.WebApp.openInvoice()`
- Анимации с использованием CSS keyframes

### 2. Backend (Flask API)

**Технологии:** Python 3.11, Flask, Gunicorn, SQLite

**Основные файлы:**
- `app.py` — основной файл Flask-приложения, API endpoints, webhook
- `lottery_engine.py` — логика проведения розыгрышей
- `bot.py` — команды бота, уведомления пользователей
- `scheduler.py` — планировщик для автоматического запуска розыгрышей

**API Endpoints:**

| Endpoint | Метод | Описание |
|----------|-------|----------|
| `/health` | GET | Health check для мониторинга |
| `/api/user/info` | POST | Получение информации о пользователе |
| `/api/create-invoice` | POST | Создание инвойса для оплаты |
| `/api/room/<room_id>` | GET | Получение информации о комнате |
| `/api/room/<room_id>/stream` | GET | SSE поток для real-time обновлений |
| `/webhook` | POST | Webhook для обработки обновлений от Telegram |

**База данных (SQLite):**

Схема базы данных включает следующие таблицы:

1. **users** — информация о пользователях
   - `user_id` (PK)
   - `username`
   - `first_name`
   - `last_name`
   - `created_at`

2. **payments** — история платежей
   - `id` (PK)
   - `user_id` (FK)
   - `amount`
   - `telegram_payment_charge_id` (уникальный)
   - `status`
   - `room_id` (FK)
   - `created_at`

3. **rooms** — игровые комнаты
   - `room_id` (PK)
   - `entry_fee`
   - `status` (waiting, drawing, completed)
   - `winner_user_id` (FK)
   - `total_pool`
   - `created_at`
   - `completed_at`

4. **room_participants** — участники комнат
   - `id` (PK)
   - `room_id` (FK)
   - `user_id` (FK)
   - `payment_id` (FK)
   - `joined_at`

5. **transactions** — аудит транзакций
   - `id` (PK)
   - `room_id` (FK)
   - `from_user_id`
   - `to_user_id`
   - `amount`
   - `transaction_type`
   - `created_at`

### 3. Telegram Bot

**Функции:**
- Обработка команд `/start`, `/help`, `/stats`
- Отправка уведомлений о результатах розыгрыша
- Установка вебхука для получения обновлений

**Режимы работы:**
- **Webhook mode** (продакшен) — Telegram отправляет обновления на `/webhook`
- **Polling mode** (разработка) — бот сам запрашивает обновления

### 4. Lottery Engine

**Основные функции:**

1. **conduct_lottery(room_id)** — проведение розыгрыша:
   - Случайный выбор победителя
   - Расчет сумм (80% победителю, 20% админу)
   - Обновление статуса комнаты
   - Запись транзакций в БД

2. **get_room_statistics()** — общая статистика по всем комнатам

3. **get_user_statistics(user_id)** — статистика конкретного пользователя

4. **cleanup_old_rooms()** — очистка старых незавершенных комнат

### 5. Scheduler

**Функция:** Автоматический запуск розыгрышей для комнат в статусе `drawing`.

**Логика:**
- Проверка комнат каждые 5 секунд
- Запуск розыгрыша для заполненных комнат
- Отправка уведомлений участникам

## Поток данных

### Сценарий 1: Пользователь присоединяется к лотерее

1. Пользователь открывает Mini App через бота
2. Frontend отправляет `initData` на `/api/user/info`
3. Backend валидирует `initData` и возвращает информацию о пользователе
4. Пользователь выбирает ставку
5. Frontend отправляет запрос на `/api/create-invoice`
6. Backend создает инвойс через Bot API
7. Frontend открывает инвойс через `Telegram.WebApp.openInvoice()`
8. Пользователь оплачивает
9. Telegram отправляет `pre_checkout_query` на `/webhook`
10. Backend проверяет возможность оплаты и отвечает через `answerPreCheckoutQuery`
11. Telegram отправляет `successful_payment` на `/webhook`
12. Backend:
    - Сохраняет платеж в БД
    - Находит или создает комнату
    - Добавляет пользователя в комнату
    - Отправляет уведомление пользователю
13. Frontend подключается к SSE потоку `/api/room/<room_id>/stream`
14. Backend отправляет обновления о заполнении комнаты

### Сценарий 2: Розыгрыш в комнате

1. Комната заполняется (6 участников)
2. Backend меняет статус комнаты на `drawing`
3. Frontend получает обновление через SSE
4. Frontend показывает экран розыгрыша с анимацией
5. Scheduler обнаруживает комнату в статусе `drawing`
6. Lottery Engine проводит розыгрыш:
   - Выбирает случайного победителя
   - Рассчитывает суммы
   - Обновляет БД
7. Backend меняет статус комнаты на `completed`
8. Frontend получает обновление через SSE
9. Frontend показывает экран победителя
10. Bot отправляет уведомления всем участникам

## Безопасность

### 1. Валидация initData

Каждый запрос от фронтенда содержит `initData` — зашифрованную строку от Telegram. Backend проверяет подлинность этой строки с помощью HMAC-SHA256:

```python
secret_key = hmac.new("WebAppData".encode(), BOT_TOKEN.encode(), hashlib.sha256).digest()
calculated_hash = hmac.new(secret_key, data_check_string.encode(), hashlib.sha256).hexdigest()
```

Это гарантирует, что запрос пришел от легитимного пользователя Telegram.

### 2. Проверка платежей

Все платежи обрабатываются через Telegram Bot API. Backend:
- Проверяет `pre_checkout_query` перед подтверждением
- Сохраняет `telegram_payment_charge_id` для возможности возврата
- Не доверяет данным только от клиента

### 3. Rate Limiting

В продакшене рекомендуется добавить rate limiting для защиты от спама и DDoS-атак. Можно использовать библиотеку `Flask-Limiter`.

### 4. CORS

CORS настроен для разрешения запросов только с домена фронтенда. В продакшене рекомендуется ограничить `CORS(app)` конкретными доменами.

## Оптимизация и масштабирование

### Текущие ограничения

1. **SQLite** — не подходит для высоких нагрузок. Для продакшена рекомендуется PostgreSQL.
2. **In-memory rooms** — состояние комнат хранится в памяти. При перезапуске сервера данные теряются. Рекомендуется использовать Redis.
3. **SSE** — односторонняя коммуникация. Для более сложных сценариев можно использовать WebSocket.

### Рекомендации для масштабирования

1. **База данных:**
   - Перейти на PostgreSQL
   - Добавить индексы для часто запрашиваемых полей
   - Использовать connection pooling

2. **Кеширование:**
   - Использовать Redis для хранения состояния комнат
   - Кешировать статистику пользователей

3. **Балансировка нагрузки:**
   - Использовать несколько инстансов Flask
   - Настроить load balancer (например, Nginx)

4. **Мониторинг:**
   - Добавить Sentry для отслеживания ошибок
   - Использовать Prometheus + Grafana для метрик

5. **Асинхронность:**
   - Перейти на асинхронный фреймворк (FastAPI, aiohttp)
   - Использовать Celery для фоновых задач

## Заключение

Архитектура приложения спроектирована с учетом простоты развертывания на бесплатных сервисах и возможности дальнейшего масштабирования. Основные принципы:

- **Модульность** — каждый компонент выполняет свою функцию
- **Безопасность** — валидация данных на всех уровнях
- **Расширяемость** — легко добавить новые функции
- **Отказоустойчивость** — обработка ошибок и логирование

Приложение готово к использованию и может обслуживать сотни пользователей одновременно на бесплатных тарифах.
